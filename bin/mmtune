#!/usr/bin/env ruby

# This utility talks over a serial connection to a RileyLink that has been
# loaded with the subg_rfspy firmware (https://github.com/ps2/subg_rfspy)

# It attempts to query pump model many times to get an estimate of connection quality

require 'minimed_rf'
require 'minimed_rf/serial'

if ARGV.length < 2 || ARGV[1].length != 6
  puts "Usage: mmtune /dev/tty.usbserial-A9048LGG pumpserial"
  if ARGV.length > 1 && ARGV[1].length != 6
    puts "Error: pumpserial should be a six character id, like '55AB12'"
  end
  exit -1
end

pump_serial = ARGV[1]

def print_packet(p)
  if p.nil?
    puts "Nil packet!"
  else
    puts "#{Time.now.strftime('%H:%M:%S.%3N')} #{"%3d" % p.rssi} (#{"%3d" % p.sequence}): #{p}"
    #puts "raw: #{p.hex_data}"
  end
end

puts "Opening #{ARGV[0]}"
rl = MinimedRF::SerialRL.new(ARGV[0])
rl.sync

# Change these to 3 and 1 when pump is detuned by body (laying on it)
rx_channel = 2
tx_channel = 0
rx_timeout_ms = 80

# Try quick model check to see if pump is awake
awake = false
3.times do
  rl.send_packet("a7" + pump_serial + "8d00", tx_channel)
  packet = rl.get_packet(rx_channel, 80)
  if packet
    print_packet(packet)
    awake = true
    break
  end
end

if !awake
  # Send 200 wake-up packets
  rl.send_packet("a7" + pump_serial + "5d00", tx_channel, 200)
  wake_ack = rl.get_packet(rx_channel, 9000) # wait 9 s for response
  if wake_ack
    print_packet(wake_ack)
  else
    puts "Pump not responding"
  end
end

# Get model
success_count = 0
40.times do
  rl.send_packet("a7" + pump_serial + "8d00", tx_channel)
  packet = rl.get_packet(rx_channel, 80)
  if packet && packet.valid?
    puts "Good!"
    success_count += 1
  else
    print_packet(packet)
  end
end

puts "Success rate: #{success_count / 40.0 * 100}%"
